function  [image_matrix, block_matrix] = runtrial_shuffle
%function  [image_matrix, block_matrix] = runtrial_shuffle

% one "block" = 1 run. 1 task at a time. Here we shuffle the 30 images for
% a run and assign it a task number 1-6, (where task 6 is split up between
% two runs because of its longer 2-epoch design)
% 1 epoch presentation: 2 on 2 off x 30
% 2 epoch presentaiton: 2 on 8 delay 2 on 2 off x 15
% 7 runs each 2.5 or 3.5 mins (<20 minutes of doing things)
% 
% 1. shuffle task order (2 wms that are not back to back) 
% 2. for each task shuffle the 30 images, wm split between two runs 
%
% Notes: 
% there will be no worry of a repeat image, since images do not repeat
% across a task and there will be breaks between tasks
%
% Outputs
% <run_matrix>      7 x 2 matrix. First column indicates run #. Second 
%                   column indicates task number(1-6). Each row is a run.
%
% <image_matrix>    180 x 3 matrix. First column is run #, second column is
%                   task number(1-6), and 3rd number is image number(1-30). 
%                   Each row is a trial. 
%
% Notes:
% What do the numbers mean? 
%   -run numbers are 1-5, ran sequentially 
%   -task numbers:
%      1 = contrast
%      2 = indoor/outdoor
%      3 = what
%      4 = where
%      5 = how
%      6 = wm
%   -unique image numbers are 1-30, image filenames are labeled with 1-30
%
%% set up variables 

p = getparams;

block_matrix = zeros(p.nruns, 3);
block_matrix(:, 1) = 1:p.nruns; % column run = run #s (1-5)

%% set block order

adjacent = true;
while adjacent == true
    block_matrix(:, 2) = shuffle([repmat([p.s_ID], 1, p.s_nruns_ses), repmat([p.d_ID], 1, p.d_nruns_ses)])'; % 5 tasks labeled 1-5 + a 6th task labeled 6 repeated twice
 
    % check for WM repeat:
    adjacent = false; 
        temp_check = diff(block_matrix(:, 2));
    if isempty(find(temp_check == 0)) % does wm repeat?
    else
       adjacent = true; % continue loop if wm has repeated
    end
end

%% set image order

% first, expand matrix to have one row per img instead of one row per block
multfactor = zeros(length(block_matrix(:, 1)), 1); % variable w scale factor for each block

for cc = 1:length(block_matrix) % for each block
    if block_matrix(cc, 2) == p.d_ID
        multfactor(cc, 1) = p.d_nimg_block; % wm sf = 15 (15 img per block)
    else
        multfactor(cc, 1) = p.s_nimg_block; % others sf = 30 (30 img per block)
    end
end

image_matrix = repelem(block_matrix, multfactor, 1); % one row per img here
block_matrix = block_matrix(:, 1:2); % to also save in format of one row per block

% now, add the images
for dd = 1:p.ntasks % for each task
    temp_task = find(image_matrix(:, 2) == dd); 
    image_matrix(temp_task, 3) = shuffle(1:p.nimg); % shuffle img # and add
end 

%% check outputs

% there are 7 blocks and 180 images
assert(length(block_matrix) == 7, 'too many blocks')
assert(length(image_matrix) == 180, 'too many trials')

% there are 30 unique imgs for each block type
for ee = 1:p.ntasks
    temp_check = find(image_matrix(:, 2) == ee);
    assert(length(temp_check) == 30, 'more than 30 trials of a task');
    assert(isempty(find(diff(image_matrix(temp_check, 3)) == 0)), 'image presented more than once in a task');
end 

% there are 6 tasks, 30 images, wm does not repeat
assert(length(unique(block_matrix(:, 2))) == p.ntasks), 'number of tasks is wrong')
assert(length(unique(image_matrix(:, 3))) == p.nimg), 'number of unique images is wrong'
assert(isempty(find(diff(block_matrix(:, 2)) == 0)), 'tasks repeat in a run')

